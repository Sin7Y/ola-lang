# Prophet Fuctions

Ola supports the "prophet" function, which utilizes prophet features to make previously difficult-to-prove but easy-to-verify computation processes now easily provable and verifiable, improving ZK circuit proof efficiency.

The following demonstrates the usage of the `u32_sqrt` prophet function supported by ola.

```rust
  fn sqrt_test(u32 n) -> (u32) {
      u32 b = u32_sqrt(n);
      return b;
  }
```

We can also use the Ola language to implement a simplified version of the sqrt function.

```rust
  // native approach
  fn sqrt_test(u32 a) -> (u32) {
      u32 result = 0;
      if (a > 3) {
          result = a;
          u32 x = a / 2 + 1;
          // assume the maximum iteration is 100
          for (u32 i = 0; i < 100; i++) {
              if (x >= result) break;
              result = x;
              x = (a / x + x) / 2;
          }
      } else if (a != 0) {
          result = 1;
      }
      return result;
  }
```

The efficiency comparison of circuit proof generated by using the Ola Prophet method and directly written in Ola language for sqrt is as follows:

![prophet\_benchmark](../.gitbook/assets/prophet\_benchmark.png)

## Core Functions

The goal of the Ola-lang high-level language library is to provide a set of high-level APIs that can be used to quickly develop applications. The Core lib functions provides commonly used functions and modules, such as Ola Standard Library, integer type operations, math calculations, `assert` function , `print` function , which can greatly improve the development efficiency of programmers.

<table><thead><tr><th width="238">function name</th><th>Params</th><th>returns</th><th>Usage</th></tr></thead><tbody><tr><td>assert</td><td>bool</td><td></td><td>assert(a == b);</td></tr><tr><td>u32_array_sort</td><td>u32 array</td><td>sorted array</td><td>u32_array_sort([2, 1, 3, 4]);</td></tr><tr><td>print</td><td>all type value</td><td></td><td>print(var_a) ;</td></tr><tr><td>caller_address</td><td></td><td>contract caller address</td><td>address caller = caller_address()</td></tr><tr><td>origin_address</td><td></td><td>contract origin caller address</td><td>address origin = origin_address()</td></tr><tr><td>code_address</td><td></td><td>current execute code contract address</td><td>address code_addr = code_address()</td></tr><tr><td>current_address</td><td></td><td>current state write and read contract address</td><td>address state_addr = current_address()</td></tr><tr><td>poseidon_hash</td><td>string/ fields</td><td>hash type</td><td>hash CREATE2_PREFIX = poseidon_hash("OlaCreate2");</td></tr><tr><td>chain_id</td><td></td><td>u32 (The future may be replaced by other data types.</td><td>u32 chainID = chain_id();</td></tr><tr><td>fields_concat</td><td>fields a and fields b</td><td>new fields</td><td>fields ret = fields_concat(a, b);</td></tr><tr><td>abi.encode</td><td>various types of uncertain quantities</td><td>fields</td><td>fields encode_value = abi.encode(a, b);</td></tr><tr><td>abi.decode</td><td>fields data wtih various types</td><td>tuple with all type value</td><td>u32 result = abi.decode(data, (u32));</td></tr><tr><td>abi.encodeWithSignature</td><td>String function selector and params</td><td>fields</td><td>fields call_data = abi.encodeWithSignature("add(u32,u32)", a, b);</td></tr><tr><td>block_number</td><td></td><td>u32</td><td>u32 blocknumber = block_number()</td></tr><tr><td>block_timestamp</td><td></td><td>u32</td><td>u32 time = block_timestamp()</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>sequence_address</td><td></td><td>address</td><td>address sequencer = sequence_address()</td></tr><tr><td>tx_version </td><td></td><td>u32</td><td>u32 version = tx_version()</td></tr><tr><td>nonce</td><td></td><td>u32</td><td>u32 nonce_number = nonce();</td></tr><tr><td>tx_hash</td><td></td><td>hash</td><td>hash h = tx_hash()</td></tr><tr><td>get_selector</td><td>string literal</td><td>u32 </td><td>u32 func_selector = get_selector()</td></tr><tr><td>signatrue</td><td></td><td>fields</td><td>fields sig = signatrue();</td></tr><tr><td>check_ecdsa</td><td>(message hash , pk,  sig)</td><td>bool</td><td>bool verify = check_ecdsa(h, pk, sig);</td></tr></tbody></table>



## Comment Lines

They are in-code documentation. When comments are inserted into the code, the compiler simply ignores them. Comment lines only serve as an aid in understanding the code.

ingle-line comments start with `//` and multi-line paragraph comments start with `/*` and end with `*/` .

Single line using`//`:

```rust
// Using this, we can comment a line.
fn main(field a) -> field {
    field b = a + 1 == 2 ? 1 : 3;
    return b;
}
```

Multi-line paragraph comments using`/*` åŠ `*/`:

```rust
fn sum(u32 a, u32 b) -> u32 {
/* 
 *  Unlike rust, the return value of 
 *  a function must be a combination of return and return value
*/
    return a + b;  
}
```